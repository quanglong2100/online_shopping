CREATE DATABASE ONLINE_SHOPPING
GO
USE ONLINE_SHOPPING


/* INDEX:
Table: line 16
Brief ideas: line 99
Trigger: line 136
View: line 270
Procedure: line 299
Audit log: line 370
Sample tables: line 812
Testing: line 886
*/

-- TABLE CREATION ___________________________________________________

CREATE TABLE CUSTOMER
( 
	CUS_ID INT IDENTITY(1,1) PRIMARY KEY,
    CUS_ACCOUNT VARCHAR(20) NOT NULL UNIQUE, -- credential
    CUS_PASSWORD VARCHAR(20) NOT NULL, -- credential
    CUS_NAME VARCHAR(50) NOT NULL,
    CUS_ADDRESS VARCHAR(MAX) NOT NULL, -- for shipping purpose
    CUS_PHONE VARCHAR(20) NOT NULL,
    CUS_EMAIL VARCHAR(50) NOT NULL,
    CUS_BANK_NAME VARCHAR(20) NOT NULL,
    CUS_BANK_NUMBER VARCHAR(20) NOT NULL
)

CREATE TABLE SHIPPER
(
    SHIP_ID INT IDENTITY(1,1) PRIMARY KEY,
    SHIP_NAME VARCHAR(50) NOT NULL,
    SHIP_PHONE VARCHAR(20) NOT NULL,
    SHIP_EMAIL VARCHAR(50) NOT NULL
)

CREATE TABLE VENDOR
(
    VEN_ID INT IDENTITY(1,1) PRIMARY KEY,
    VEN_NAME VARCHAR(50) NOT NULL,
    VEN_ADDRESS VARCHAR(MAX) NOT NULL,
    VEN_DESCRIPTION VARCHAR(MAX) -- general description; throw anything in here.
)

CREATE TABLE ITEM
(
    ITEM_ID INT IDENTITY(1,1) PRIMARY KEY,
    ITEM_DESCRIPTION VARCHAR(MAX), -- general description; throw anything in here.
    ITEM_TYPE VARCHAR(20) NOT NULL, -- type of item for advertising and sorting purposes.
    ITEM_PRICE INT NOT NULL, -- price per unit.
    ITEM_AMOUNT INT NOT NULL CHECK (ITEM_AMOUNT >= 0), -- remaining amount in storage.
    VEN_ID INT NOT NULL REFERENCES VENDOR(VEN_ID)
)

CREATE TABLE CART
(
    ID INT IDENTITY(1,1) PRIMARY KEY,
    CUS_ID INT NOT NULL UNIQUE REFERENCES CUSTOMER(CUS_ID), -- 1 cart per person.
    TOTAL_PRICE INT -- total price of all items placed in cart.
)

CREATE TABLE CART_ORDER -- link table between CART and ITEM to avoid M-N. Also serve "add item to cart" procedure action.
(
    CUS_ID INT NOT NULL REFERENCES CUSTOMER(CUS_ID),
    ITEM_ID INT NOT NULL REFERENCES ITEM(ITEM_ID),
    AMOUNT INT NOT NULL CHECK (AMOUNT >= 0) -- LOWEST AMOUNT = 0.
    PRIMARY KEY (CUS_ID, ITEM_ID)
)

CREATE TABLE ADVERTISEMENT
(
    ADS_ID INT IDENTITY(1,1) PRIMARY KEY,
    CUS_ID INT NOT NULL REFERENCES CUSTOMER(CUS_ID),
    ADS_DESCRIPTION VARCHAR(MAX)
)

CREATE TABLE DEAL -- Cumulative history of all transactions.
(
    DEAL_ID INT IDENTITY(1,1) PRIMARY KEY,
    CUS_ID INT NOT NULL REFERENCES CUSTOMER(CUS_ID),
    TOTAL_PRICE INT NOT NULL,
    DEAL_TIME SMALLDATETIME NOT NULL, -- time of purchase.
    SHIP_ID INT NOT NULL REFERENCES SHIPPER(SHIP_ID), -- assigned shipper.
    SHIP_STATUS VARCHAR(20) NOT NULL DEFAULT 'NOT SHIPPED' CHECK (SHIP_STATUS IN ('NOT SHIPPED', 'SHIPPED', 'RETURNED')), -- 'NOT SHIPPED', 'SHIPPED', or 'RETURNED'.
    SHIP_TIME SMALLDATETIME -- time done shipping.
)

CREATE TABLE DEAL_ORDER -- link table between DEAL and ITEM to avoid M-N.
(
    DEAL_ID INT NOT NULL REFERENCES DEAL(DEAL_ID),
    ITEM_ID INT NOT NULL REFERENCES ITEM(ITEM_ID),
    AMOUNT INT NOT NULL
    PRIMARY KEY (DEAL_ID, ITEM_ID)
)

--------------------------------------------------------------------------------
/* IDEAS:

- When customers add items to their carts, they are actually inserting new rows into CART_ORDER table. (PROCEDURE)
After a new row is inserted/updated/deleted in CART_ORDER table, CART is automatically triggered to reflect the latest TOTAL_PRICE. (TRIGGER)
TOTAL_PRICE is calculated by multiplying items' prices by their respective amounts, then sum all items a person has.

- A view table can be created by joining CART_ORDER and ITEM to show what items a customer currently has in his/her cart, and their respective amounts. (PROCEDURE)

- When a customer purchases a cart, it actually deletes that customer's row in CART. (PROCEDURE)
Before a row in CART is deleted, DEAL is triggered to record everything, automatically register action time, and assign a random shipper. (TRIGGER)
After a row in DEAL is created, DEAL_ORDER is triggered to pull that customer's data from CART_ORDER, and attach the newly-created DEAL_ID to those rows for record purpose. (TRIGGER)
After the data in DEAL_ORDER is created, records in CART_ORDER are cleared, ready for a new cart/new purchases. (TRIGGER)

- Before a purchase is executed, the system checks for the remaining amount of items in storage.
If the amounts suffice, the purchase command is executed and the respective amounts are deducted accordingly. (TRIGGER)
If not, return Error and stop action.

- Transaction history (DEAL) and CART tables are separated for faster query time purpose.

- A shipping slip can be created by joining SHIPPER, DEAL, CUSTOMER, DEAL_ORDER, ITEM, and VENDOR to print vendors' addresses, items and amounts, customer's address, and customer's phone for shipping purpose. (PROCEDURE)
As known as the small piece of paper containing info glued on the box for shipping purpose.

- ADSVERTISEMENT table can be automatically triggered whenever a customer add an item to his/her cart -> search for a random item of the same TYPE -> recommend to that customer. (TRIGGER)
More advanced: with the presence of DEAL_ID and a significant enough dataset, a model can be trained to detect items usually purchased together (in the same cart) and suggest those items for higher success rate.

+ VIEW: View on DEAL where STATUS = 'NOT SHIPPED' to check on lazy shippers.
+ VIEW: View on DEAL count where STATUS = 'SHIPPED' to check level of success.
+ VIEW: View on CART_ORDER -> count total number of items in cart, grouped by items to actively monitor which products customers are hesitating to buy
to accommodate them with timely sale off programs, further boost website's reputation. (or increase the price because of high demand. Show them some Capitalism.)
+ PROCEDURE: Shippers register finished deliveries.

/!\ AUDIT LOG: Check 4 tables CUSTOMER, SHIPPER, ITEM, VENDOR because they contain important basic data.
Separate each table into 3 triggers (insert, delete, update) in order to use Cursor to handle bulk activation (SQL Server fires trigger once per statement and no FOR EACH ROW).
*/

GO
--------------------------------------------------------------------------------
-- TRIGGER ___________________________________________________

-- TRIGGER FOR ADS WHENEVER AN ITEM IS ADDED TO CART.
CREATE TRIGGER ADS_TRIGGER
ON CART_ORDER
AFTER INSERT
AS

DECLARE @ITEM_ORDER INT -- GET ITEM'S ID.
SELECT @ITEM_ORDER = I.ITEM_ID FROM INSERTED AS I
DECLARE @ITEM_TYPE VARCHAR(20) -- GET ITEM'S TYPE FROM THE PREVIOUS ITEM'S ID.
SELECT @ITEM_TYPE = I.ITEM_TYPE FROM ITEM AS I WHERE I.ITEM_ID = @ITEM_ORDER

DECLARE @NEW_ITEM_ID INT
DECLARE @NEW_ITEM_DES VARCHAR(MAX)
SELECT TOP 1 @NEW_ITEM_ID = I.ITEM_ID, @NEW_ITEM_DES = I.ITEM_DESCRIPTION -- GET A NEW RANDOM ROW IN ITEM WITH THE SAME ITEM'S TYPE.
FROM ITEM AS I WHERE I.ITEM_TYPE = @ITEM_TYPE ORDER BY NEWID(); -- NEWID() GIVES A RANDOM VALUE TO EACH ROW.

DECLARE @CUS_ORDER INT
SELECT @CUS_ORDER = I.CUS_ID FROM INSERTED AS I

BEGIN
INSERT INTO ADVERTISEMENT (CUS_ID, ADS_DESCRIPTION) VALUES (@CUS_ORDER, CONCAT('TAKE A LOOK AT ITEM ID ', @NEW_ITEM_ID, ' NAMED ', @NEW_ITEM_DES, '.'));
END;

GO

-- TRIGGER FOR CALCULATING TOTAL PRICE OF A CART.
CREATE TRIGGER TOTAL_CART_TRIGGER
ON CART_ORDER
AFTER INSERT, UPDATE
AS

DECLARE @CUS_ORDER INT
SELECT @CUS_ORDER = I.CUS_ID FROM INSERTED AS I

DECLARE @TOTAL_PRICE INT;
SELECT @TOTAL_PRICE = SUM(CO.AMOUNT*I.ITEM_PRICE)
FROM CART_ORDER AS CO
JOIN ITEM AS I ON CO.ITEM_ID = I.ITEM_ID
WHERE CO.CUS_ID = @CUS_ORDER GROUP BY CO.CUS_ID;

BEGIN
    UPDATE CART
    SET TOTAL_PRICE = @TOTAL_PRICE
    WHERE CUS_ID = @CUS_ORDER
    IF @@ROWCOUNT = 0 -- UPDATE IF EXIST, ELSE INSERT.
    BEGIN
        INSERT INTO CART (CUS_ID, TOTAL_PRICE)
        VALUES (@CUS_ORDER, @TOTAL_PRICE)
    END
END

GO

-- TRIGGER FOR RECORDING TRANSACTION HISTORY ON PURCHASE (CART DELETION).
CREATE TRIGGER RECORD_DEAL
ON CART
AFTER DELETE
AS

DECLARE @CUS_ID INT
SELECT @CUS_ID = DELETED.CUS_ID FROM DELETED
DECLARE @TOTAL_PRICE INT
SELECT @TOTAL_PRICE = DELETED.TOTAL_PRICE FROM DELETED
DECLARE @SHIP_ID INT
SELECT @SHIP_ID = SHIPPER.SHIP_ID FROM SHIPPER ORDER BY NEWID();

BEGIN
INSERT INTO DEAL (CUS_ID, TOTAL_PRICE, DEAL_TIME, SHIP_ID)
VALUES (@CUS_ID, @TOTAL_PRICE, GETDATE(), @SHIP_ID)
END

GO

-- TRIGGER FOR LINKED TABLE FOR TRANSACTION HISTORY.
CREATE TRIGGER RECORD_DEAL_ORDER
ON DEAL
AFTER INSERT
AS

DECLARE @DEAL_ID INT
SELECT @DEAL_ID = INSERTED.DEAL_ID FROM INSERTED
DECLARE @CUS_ID INT
SELECT @CUS_ID = INSERTED.CUS_ID FROM INSERTED

BEGIN
INSERT INTO DEAL_ORDER (DEAL_ID, ITEM_ID, AMOUNT)
SELECT @DEAL_ID, ITEM_ID, AMOUNT FROM CART_ORDER WHERE CUS_ID = @CUS_ID -- NO NEED FOR CURSOR AS WE ARE DOING BULK COPY.
END

GO

-- TRIGGER FOR CLEARING LINKED TABLE OF CART (AS CART IS CLEARED).
CREATE TRIGGER CLEAR_CART
ON DEAL_ORDER
AFTER INSERT
AS

DECLARE @CUS_ID INT
SELECT @CUS_ID = CUS_ID
FROM DEAL
WHERE DEAL_ID = (SELECT TOP 1 DEAL_ID FROM INSERTED)

BEGIN
DELETE FROM CART_ORDER WHERE CUS_ID = @CUS_ID
END

GO

-- TRIGGER FOR CLEARING STORAGE AFTER PURCHASE.
CREATE TRIGGER CLEAR_STORAGE
ON CART_ORDER
AFTER DELETE
AS

DECLARE @ITEM_CLEAR_STORAGE INT
DECLARE @AMOUNT_CLEAR_STORAGE INT
DECLARE CURSOR_CLEAR_STORAGE CURSOR -- UTILIZE CURSOR TO CHECK FOR EACH ROW.
FOR
SELECT ITEM_ID, AMOUNT FROM DELETED
OPEN CURSOR_CLEAR_STORAGE
FETCH NEXT FROM CURSOR_CLEAR_STORAGE INTO @ITEM_CLEAR_STORAGE, @AMOUNT_CLEAR_STORAGE
WHILE @@FETCH_STATUS=0
BEGIN
    UPDATE ITEM
    SET ITEM_AMOUNT = ITEM_AMOUNT - @AMOUNT_CLEAR_STORAGE WHERE ITEM_ID = @ITEM_CLEAR_STORAGE
    FETCH NEXT FROM CURSOR_CLEAR_STORAGE INTO @ITEM_CLEAR_STORAGE, @AMOUNT_CLEAR_STORAGE
END
CLOSE CURSOR_CLEAR_STORAGE

GO

--------------------------------------------------------------------------------
-- VIEW ___________________________________________________

-- VIEW OF PENDING DEALS, ORDERED FROM WORST TO "BEST". A LITTLE BIT OF SKETCH HONESTLY, BUT IT WORKED.
CREATE VIEW NOT_SHIPPED_DEALS AS
SELECT TOP 999999999999 DEAL_ID, DEAL_TIME, SHIP_ID, DATEDIFF(HOUR, DEAL_TIME, GETDATE()) as DELAY_TIME_HOURS
FROM DEAL
WHERE SHIP_STATUS = 'NOT SHIPPED'
ORDER BY DELAY_TIME_HOURS DESC

GO

-- HOW MANY DEALS COMPLETED?
CREATE VIEW SUCCESSFUL_DEALS_COUNT AS
SELECT COUNT(SHIP_STATUS) AS TOTAL
FROM DEAL
WHERE SHIP_STATUS = 'SHIPPED'

GO

-- ITEMS THAT CUSTOMERS WANT TO BUY, BUT STILL HESITATE. TIME TO SHOW THEM CAPITALISM.
CREATE VIEW CART_PENDING AS
SELECT TOP 999999999999 I.ITEM_ID, I.ITEM_DESCRIPTION, I.ITEM_PRICE, SUM(CO.AMOUNT) AS PENDING_AMOUNT, I.ITEM_AMOUNT AS REMAINING_AMOUNT
FROM CART_ORDER AS CO JOIN ITEM AS I ON CO.ITEM_ID = I.ITEM_ID
GROUP BY I.ITEM_ID, I.ITEM_DESCRIPTION, I.ITEM_PRICE, I.ITEM_AMOUNT
ORDER BY SUM(CO.AMOUNT) DESC

GO

--------------------------------------------------------------------------------
-- PROCEDURE ___________________________________________________

-- ADD ITEMS TO CART OR UPDATE CURRENT AMOUNT.
CREATE PROCEDURE ADD_TO_CART @CUS INT, @ITEM INT, @AMOUNT INT
AS
IF EXISTS (SELECT * FROM CART_ORDER WHERE CUS_ID = @CUS AND ITEM_ID = @ITEM)
    BEGIN
        UPDATE CART_ORDER
        SET AMOUNT = @AMOUNT
        WHERE CUS_ID = @CUS AND ITEM_ID = @ITEM
    END
ELSE
    BEGIN
        INSERT INTO CART_ORDER (CUS_ID, ITEM_ID, AMOUNT)
        VALUES (@CUS, @ITEM, @AMOUNT)
    END

GO

-- PROCEDURE FOR EACH INDIVIDUAL TO VIEW HIS/HER OWN CART.
CREATE PROCEDURE VIEW_CART @CUS INT
AS
SELECT I.ITEM_ID, I.ITEM_DESCRIPTION, I.ITEM_PRICE, CO.AMOUNT AS PENDING_AMOUNT, I.ITEM_AMOUNT AS REMAINING_AMOUNT
FROM CART_ORDER AS CO JOIN ITEM AS I ON CO.ITEM_ID = I.ITEM_ID
WHERE CO.CUS_ID = @CUS

GO

-- PROCEDURE TO PURCHASE_CART. ONLY EXECUTE IF SUFFICIENT AMOUNT IN STORAGE.
CREATE PROCEDURE PURCHASE_CART @CUS INT
AS
IF EXISTS (SELECT I.ITEM_ID, I.ITEM_DESCRIPTION, I.ITEM_PRICE, CO.AMOUNT AS PENDING_AMOUNT, I.ITEM_AMOUNT AS REMAINING_AMOUNT
FROM CART_ORDER AS CO JOIN ITEM AS I ON CO.ITEM_ID = I.ITEM_ID
WHERE CO.CUS_ID = @CUS AND CO.AMOUNT > I.ITEM_AMOUNT) -- CHECK IF AMOUNT IS SUFFICIENT.
    BEGIN
        PRINT 'THESE ITEMS IN YOUR CART DOES NOT HAVE SUFFICIENT AMOUNT IN STORAGE.' -- IF NOT, STOP THE EXECUTION AND SHOW WHICH ITEMS HAVE AMOUNT IN CART EXCEED AMOUNT IN STORAGE.
        SELECT I.ITEM_ID, I.ITEM_DESCRIPTION, I.ITEM_PRICE, CO.AMOUNT AS PENDING_AMOUNT, I.ITEM_AMOUNT AS REMAINING_AMOUNT
        FROM CART_ORDER AS CO JOIN ITEM AS I ON CO.ITEM_ID = I.ITEM_ID
        WHERE CO.CUS_ID = @CUS AND CO.AMOUNT > I.ITEM_AMOUNT
    END
ELSE
    BEGIN -- IF YES, EXECUTE. THE TRIGGERS WILL TAKE CARE OF THE REST.
        DELETE FROM CART WHERE CUS_ID = @CUS
        PRINT 'YOU HAVE SUCCESSFULLY MADE THE PURCHASE.'
    END

GO

-- SHIPPING LABELS TO STICK ON BOXES FOR DELIVERY.
CREATE PROCEDURE SHIPPING_SLIP @DEAL_ID INT
AS
SELECT D.DEAL_ID, D.SHIP_ID, DO.ITEM_ID, I.ITEM_DESCRIPTION, DO.AMOUNT, C.CUS_ADDRESS AS CUSTOMER__ADDRESS, V.VEN_ADDRESS AS VENDOR_ADRESS
FROM DEAL AS D
JOIN CUSTOMER AS C ON D.CUS_ID = C.CUS_ID
JOIN DEAL_ORDER AS DO ON D.DEAL_ID = DO.DEAL_ID
JOIN ITEM AS I ON DO.ITEM_ID = I.ITEM_ID
JOIN VENDOR AS V ON I.VEN_ID = V.VEN_ID
WHERE D.DEAL_ID = @DEAL_ID

GO

-- SHIPPER REGISTERS FINISHED DELIVERY.
CREATE PROCEDURE FINISHED_DELIVERY @DEAL_ID INT
AS
UPDATE DEAL
SET SHIP_STATUS = 'SHIPPED', SHIP_TIME = GETDATE()
WHERE DEAL_ID = @DEAL_ID

GO

--------------------------------------------------------------------------------
/* ADMIN TRIGGER TABLE TO TRACK CHANGES */
-- I CHECK 4 TABLES: CUSTOMER, SHIPPER, ITEM, VENDOR BECAUSE THEY CONTAIN BASIC IMPORTANT DATA.
-- I had to separate each table into 3 triggers (insert, delete, update) in order to use Cursor to handle bulk activation (SQL Server fires trigger once per statement and no FOR EACH ROW).
CREATE TABLE CHECK_CHANGES
(
    TABLE_NAME VARCHAR(20) NOT NULL, -- TABLE NAME
    COLUMN_NAME VARCHAR(20) NOT NULL, -- COLUMN NAME
    ROW_ID VARCHAR(20) NOT NULL, -- ID OF THE SPECIFIC ROW IN THE TABLE MENTIONED ABOVE.
    OLD_DATA VARCHAR(MAX), -- OLD DATA (NULL IF INSERT)
    NEW_DATA VARCHAR(MAX), -- NEW DATA (NULL IF DELETE)
    CHANGE_TIME SMALLDATETIME -- ACTION TIME
)

GO
-- CHECK CHANGES ON CUSTOMER INFORMATION.
-- CUSTOMER INSERT.
CREATE TRIGGER TRIGGER_CHECK_CHANGES_CUSTOMER_INSERT
ON CUSTOMER
AFTER INSERT
AS
DECLARE @OLD_CUS_ACCOUNT VARCHAR(MAX)
DECLARE @NEW_CUS_ACCOUNT VARCHAR(MAX)
DECLARE @OLD_CUS_PASSWORD VARCHAR(MAX)
DECLARE @NEW_CUS_PASSWORD VARCHAR(MAX)
DECLARE @OLD_CUS_NAME VARCHAR(MAX)
DECLARE @NEW_CUS_NAME VARCHAR(MAX)
DECLARE @OLD_CUS_ADDRESS VARCHAR(MAX)
DECLARE @NEW_CUS_ADDRESS VARCHAR(MAX)
DECLARE @OLD_CUS_PHONE VARCHAR(MAX)
DECLARE @NEW_CUS_PHONE VARCHAR(MAX)
DECLARE @OLD_CUS_EMAIL VARCHAR(MAX)
DECLARE @NEW_CUS_EMAIL VARCHAR(MAX)
DECLARE @OLD_CUS_BANK_NAME VARCHAR(MAX)
DECLARE @NEW_CUS_BANK_NAME VARCHAR(MAX)
DECLARE @OLD_CUS_BANK_NUMBER VARCHAR(MAX)
DECLARE @NEW_CUS_BANK_NUMBER VARCHAR(MAX)
DECLARE @ROW_ID INT

DECLARE CURSOR_CHECK_CHANGES_CUSTOMER_INSERT CURSOR FOR
SELECT INSERTED.CUS_ID, INSERTED.CUS_ACCOUNT, INSERTED.CUS_PASSWORD, INSERTED.CUS_NAME, INSERTED.CUS_ADDRESS, INSERTED.CUS_PHONE, INSERTED.CUS_EMAIL, INSERTED.CUS_BANK_NAME, INSERTED.CUS_BANK_NUMBER FROM INSERTED
OPEN CURSOR_CHECK_CHANGES_CUSTOMER_INSERT
FETCH NEXT FROM CURSOR_CHECK_CHANGES_CUSTOMER_INSERT INTO @ROW_ID, @NEW_CUS_ACCOUNT, @NEW_CUS_PASSWORD, @NEW_CUS_NAME, @NEW_CUS_ADDRESS, @NEW_CUS_PHONE, @NEW_CUS_EMAIL, @NEW_CUS_BANK_NAME, @NEW_CUS_BANK_NUMBER
WHILE @@FETCH_STATUS=0
BEGIN
    IF @OLD_CUS_ACCOUNT != @NEW_CUS_ACCOUNT OR (@OLD_CUS_ACCOUNT IS NULL AND @NEW_CUS_ACCOUNT IS NOT NULL) OR (@OLD_CUS_ACCOUNT IS NOT NULL AND @NEW_CUS_ACCOUNT IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_ACCOUNT', @OLD_CUS_ACCOUNT, @NEW_CUS_ACCOUNT, GETDATE())
    IF @OLD_CUS_PASSWORD != @NEW_CUS_PASSWORD OR (@OLD_CUS_PASSWORD IS NULL AND @NEW_CUS_PASSWORD IS NOT NULL) OR (@OLD_CUS_PASSWORD IS NOT NULL AND @NEW_CUS_PASSWORD IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_PASSWORD', @OLD_CUS_PASSWORD, @NEW_CUS_PASSWORD, GETDATE())
    IF @OLD_CUS_NAME != @NEW_CUS_NAME OR (@OLD_CUS_NAME IS NULL AND @NEW_CUS_NAME IS NOT NULL) OR (@OLD_CUS_NAME IS NOT NULL AND @NEW_CUS_NAME IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_NAME', @OLD_CUS_NAME, @NEW_CUS_NAME, GETDATE())
    IF @OLD_CUS_ADDRESS != @NEW_CUS_ADDRESS OR (@OLD_CUS_ADDRESS IS NULL AND @NEW_CUS_ADDRESS IS NOT NULL) OR (@OLD_CUS_ADDRESS IS NOT NULL AND @NEW_CUS_ADDRESS IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_ADDRESS', @OLD_CUS_ADDRESS, @NEW_CUS_ADDRESS, GETDATE())
    IF @OLD_CUS_PHONE != @NEW_CUS_PHONE OR (@OLD_CUS_PHONE IS NULL AND @NEW_CUS_PHONE IS NOT NULL) OR (@OLD_CUS_PHONE IS NOT NULL AND @NEW_CUS_PHONE IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_PHONE', @OLD_CUS_PHONE, @NEW_CUS_PHONE, GETDATE())
    IF @OLD_CUS_EMAIL != @NEW_CUS_EMAIL OR (@OLD_CUS_EMAIL IS NULL AND @NEW_CUS_EMAIL IS NOT NULL) OR (@OLD_CUS_EMAIL IS NOT NULL AND @NEW_CUS_EMAIL IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_EMAIL', @OLD_CUS_EMAIL, @NEW_CUS_EMAIL, GETDATE())
    IF @OLD_CUS_BANK_NAME != @NEW_CUS_BANK_NAME OR (@OLD_CUS_BANK_NAME IS NULL AND @NEW_CUS_BANK_NAME IS NOT NULL) OR (@OLD_CUS_BANK_NAME IS NOT NULL AND @NEW_CUS_BANK_NAME IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_BANK_NAME', @OLD_CUS_BANK_NAME, @NEW_CUS_BANK_NAME, GETDATE())
    IF @OLD_CUS_BANK_NUMBER != @NEW_CUS_BANK_NUMBER OR (@OLD_CUS_BANK_NUMBER IS NULL AND @NEW_CUS_BANK_NUMBER IS NOT NULL) OR (@OLD_CUS_BANK_NUMBER IS NOT NULL AND @NEW_CUS_BANK_NUMBER IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_BANK_NUMBER', @OLD_CUS_BANK_NUMBER, @NEW_CUS_BANK_NUMBER, GETDATE())
    FETCH NEXT FROM CURSOR_CHECK_CHANGES_CUSTOMER_INSERT INTO @ROW_ID, @NEW_CUS_ACCOUNT, @NEW_CUS_PASSWORD, @NEW_CUS_NAME, @NEW_CUS_ADDRESS, @NEW_CUS_PHONE, @NEW_CUS_EMAIL, @NEW_CUS_BANK_NAME, @NEW_CUS_BANK_NUMBER
END
CLOSE CURSOR_CHECK_CHANGES_CUSTOMER_INSERT

GO
-- CUSTOMER DELETE.
CREATE TRIGGER TRIGGER_CHECK_CHANGES_CUSTOMER_DELETE
ON CUSTOMER
AFTER DELETE
AS
DECLARE @OLD_CUS_ACCOUNT VARCHAR(MAX)
DECLARE @NEW_CUS_ACCOUNT VARCHAR(MAX)
DECLARE @OLD_CUS_PASSWORD VARCHAR(MAX)
DECLARE @NEW_CUS_PASSWORD VARCHAR(MAX)
DECLARE @OLD_CUS_NAME VARCHAR(MAX)
DECLARE @NEW_CUS_NAME VARCHAR(MAX)
DECLARE @OLD_CUS_ADDRESS VARCHAR(MAX)
DECLARE @NEW_CUS_ADDRESS VARCHAR(MAX)
DECLARE @OLD_CUS_PHONE VARCHAR(MAX)
DECLARE @NEW_CUS_PHONE VARCHAR(MAX)
DECLARE @OLD_CUS_EMAIL VARCHAR(MAX)
DECLARE @NEW_CUS_EMAIL VARCHAR(MAX)
DECLARE @OLD_CUS_BANK_NAME VARCHAR(MAX)
DECLARE @NEW_CUS_BANK_NAME VARCHAR(MAX)
DECLARE @OLD_CUS_BANK_NUMBER VARCHAR(MAX)
DECLARE @NEW_CUS_BANK_NUMBER VARCHAR(MAX)
DECLARE @ROW_ID INT

DECLARE CURSOR_CHECK_CHANGES_CUSTOMER_DELETE CURSOR FOR
SELECT DELETED.CUS_ID, DELETED.CUS_ACCOUNT, DELETED.CUS_PASSWORD, DELETED.CUS_NAME, DELETED.CUS_ADDRESS, DELETED.CUS_PHONE, DELETED.CUS_EMAIL, DELETED.CUS_BANK_NAME, DELETED.CUS_BANK_NUMBER FROM DELETED
OPEN CURSOR_CHECK_CHANGES_CUSTOMER_DELETE
FETCH NEXT FROM CURSOR_CHECK_CHANGES_CUSTOMER_DELETE INTO @ROW_ID, @OLD_CUS_ACCOUNT, @OLD_CUS_PASSWORD, @OLD_CUS_NAME, @OLD_CUS_ADDRESS, @OLD_CUS_PHONE, @OLD_CUS_EMAIL, @OLD_CUS_BANK_NAME, @OLD_CUS_BANK_NUMBER
WHILE @@FETCH_STATUS=0
BEGIN
    IF @OLD_CUS_ACCOUNT != @NEW_CUS_ACCOUNT OR (@OLD_CUS_ACCOUNT IS NULL AND @NEW_CUS_ACCOUNT IS NOT NULL) OR (@OLD_CUS_ACCOUNT IS NOT NULL AND @NEW_CUS_ACCOUNT IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_ACCOUNT', @OLD_CUS_ACCOUNT, @NEW_CUS_ACCOUNT, GETDATE())
    IF @OLD_CUS_PASSWORD != @NEW_CUS_PASSWORD OR (@OLD_CUS_PASSWORD IS NULL AND @NEW_CUS_PASSWORD IS NOT NULL) OR (@OLD_CUS_PASSWORD IS NOT NULL AND @NEW_CUS_PASSWORD IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_PASSWORD', @OLD_CUS_PASSWORD, @NEW_CUS_PASSWORD, GETDATE())
    IF @OLD_CUS_NAME != @NEW_CUS_NAME OR (@OLD_CUS_NAME IS NULL AND @NEW_CUS_NAME IS NOT NULL) OR (@OLD_CUS_NAME IS NOT NULL AND @NEW_CUS_NAME IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_NAME', @OLD_CUS_NAME, @NEW_CUS_NAME, GETDATE())
    IF @OLD_CUS_ADDRESS != @NEW_CUS_ADDRESS OR (@OLD_CUS_ADDRESS IS NULL AND @NEW_CUS_ADDRESS IS NOT NULL) OR (@OLD_CUS_ADDRESS IS NOT NULL AND @NEW_CUS_ADDRESS IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_ADDRESS', @OLD_CUS_ADDRESS, @NEW_CUS_ADDRESS, GETDATE())
    IF @OLD_CUS_PHONE != @NEW_CUS_PHONE OR (@OLD_CUS_PHONE IS NULL AND @NEW_CUS_PHONE IS NOT NULL) OR (@OLD_CUS_PHONE IS NOT NULL AND @NEW_CUS_PHONE IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_PHONE', @OLD_CUS_PHONE, @NEW_CUS_PHONE, GETDATE())
    IF @OLD_CUS_EMAIL != @NEW_CUS_EMAIL OR (@OLD_CUS_EMAIL IS NULL AND @NEW_CUS_EMAIL IS NOT NULL) OR (@OLD_CUS_EMAIL IS NOT NULL AND @NEW_CUS_EMAIL IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_EMAIL', @OLD_CUS_EMAIL, @NEW_CUS_EMAIL, GETDATE())
    IF @OLD_CUS_BANK_NAME != @NEW_CUS_BANK_NAME OR (@OLD_CUS_BANK_NAME IS NULL AND @NEW_CUS_BANK_NAME IS NOT NULL) OR (@OLD_CUS_BANK_NAME IS NOT NULL AND @NEW_CUS_BANK_NAME IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_BANK_NAME', @OLD_CUS_BANK_NAME, @NEW_CUS_BANK_NAME, GETDATE())
    IF @OLD_CUS_BANK_NUMBER != @NEW_CUS_BANK_NUMBER OR (@OLD_CUS_BANK_NUMBER IS NULL AND @NEW_CUS_BANK_NUMBER IS NOT NULL) OR (@OLD_CUS_BANK_NUMBER IS NOT NULL AND @NEW_CUS_BANK_NUMBER IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_BANK_NUMBER', @OLD_CUS_BANK_NUMBER, @NEW_CUS_BANK_NUMBER, GETDATE())
    FETCH NEXT FROM CURSOR_CHECK_CHANGES_CUSTOMER_DELETE INTO @ROW_ID, @OLD_CUS_ACCOUNT, @OLD_CUS_PASSWORD, @OLD_CUS_NAME, @OLD_CUS_ADDRESS, @OLD_CUS_PHONE, @OLD_CUS_EMAIL, @OLD_CUS_BANK_NAME, @OLD_CUS_BANK_NUMBER
END
CLOSE CURSOR_CHECK_CHANGES_CUSTOMER_DELETE

GO
-- CUSTOMER UPDATE.
CREATE TRIGGER TRIGGER_CHECK_CHANGES_CUSTOMER_UPDATE
ON CUSTOMER
AFTER UPDATE
AS
DECLARE @OLD_CUS_ACCOUNT VARCHAR(MAX)
DECLARE @NEW_CUS_ACCOUNT VARCHAR(MAX)
DECLARE @OLD_CUS_PASSWORD VARCHAR(MAX)
DECLARE @NEW_CUS_PASSWORD VARCHAR(MAX)
DECLARE @OLD_CUS_NAME VARCHAR(MAX)
DECLARE @NEW_CUS_NAME VARCHAR(MAX)
DECLARE @OLD_CUS_ADDRESS VARCHAR(MAX)
DECLARE @NEW_CUS_ADDRESS VARCHAR(MAX)
DECLARE @OLD_CUS_PHONE VARCHAR(MAX)
DECLARE @NEW_CUS_PHONE VARCHAR(MAX)
DECLARE @OLD_CUS_EMAIL VARCHAR(MAX)
DECLARE @NEW_CUS_EMAIL VARCHAR(MAX)
DECLARE @OLD_CUS_BANK_NAME VARCHAR(MAX)
DECLARE @NEW_CUS_BANK_NAME VARCHAR(MAX)
DECLARE @OLD_CUS_BANK_NUMBER VARCHAR(MAX)
DECLARE @NEW_CUS_BANK_NUMBER VARCHAR(MAX)
DECLARE @ROW_ID INT

DECLARE CURSOR_CHECK_CHANGES_CUSTOMER_UPDATE CURSOR FOR
SELECT INSERTED.CUS_ID, INSERTED.CUS_ACCOUNT, INSERTED.CUS_PASSWORD, INSERTED.CUS_NAME, INSERTED.CUS_ADDRESS, INSERTED.CUS_PHONE, INSERTED.CUS_EMAIL, INSERTED.CUS_BANK_NAME, INSERTED.CUS_BANK_NUMBER, DELETED.CUS_ACCOUNT, DELETED.CUS_PASSWORD, DELETED.CUS_NAME, DELETED.CUS_ADDRESS, DELETED.CUS_PHONE, DELETED.CUS_EMAIL, DELETED.CUS_BANK_NAME, DELETED.CUS_BANK_NUMBER FROM INSERTED JOIN DELETED ON INSERTED.CUS_ID = DELETED.CUS_ID
OPEN CURSOR_CHECK_CHANGES_CUSTOMER_UPDATE
FETCH NEXT FROM CURSOR_CHECK_CHANGES_CUSTOMER_UPDATE INTO @ROW_ID, @NEW_CUS_ACCOUNT, @NEW_CUS_PASSWORD, @NEW_CUS_NAME, @NEW_CUS_ADDRESS, @NEW_CUS_PHONE, @NEW_CUS_EMAIL, @NEW_CUS_BANK_NAME, @NEW_CUS_BANK_NUMBER, @OLD_CUS_ACCOUNT, @OLD_CUS_PASSWORD, @OLD_CUS_NAME, @OLD_CUS_ADDRESS, @OLD_CUS_PHONE, @OLD_CUS_EMAIL, @OLD_CUS_BANK_NAME, @OLD_CUS_BANK_NUMBER
WHILE @@FETCH_STATUS=0
BEGIN
    IF @OLD_CUS_ACCOUNT != @NEW_CUS_ACCOUNT OR (@OLD_CUS_ACCOUNT IS NULL AND @NEW_CUS_ACCOUNT IS NOT NULL) OR (@OLD_CUS_ACCOUNT IS NOT NULL AND @NEW_CUS_ACCOUNT IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_ACCOUNT', @OLD_CUS_ACCOUNT, @NEW_CUS_ACCOUNT, GETDATE())
    IF @OLD_CUS_PASSWORD != @NEW_CUS_PASSWORD OR (@OLD_CUS_PASSWORD IS NULL AND @NEW_CUS_PASSWORD IS NOT NULL) OR (@OLD_CUS_PASSWORD IS NOT NULL AND @NEW_CUS_PASSWORD IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_PASSWORD', @OLD_CUS_PASSWORD, @NEW_CUS_PASSWORD, GETDATE())
    IF @OLD_CUS_NAME != @NEW_CUS_NAME OR (@OLD_CUS_NAME IS NULL AND @NEW_CUS_NAME IS NOT NULL) OR (@OLD_CUS_NAME IS NOT NULL AND @NEW_CUS_NAME IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_NAME', @OLD_CUS_NAME, @NEW_CUS_NAME, GETDATE())
    IF @OLD_CUS_ADDRESS != @NEW_CUS_ADDRESS OR (@OLD_CUS_ADDRESS IS NULL AND @NEW_CUS_ADDRESS IS NOT NULL) OR (@OLD_CUS_ADDRESS IS NOT NULL AND @NEW_CUS_ADDRESS IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_ADDRESS', @OLD_CUS_ADDRESS, @NEW_CUS_ADDRESS, GETDATE())
    IF @OLD_CUS_PHONE != @NEW_CUS_PHONE OR (@OLD_CUS_PHONE IS NULL AND @NEW_CUS_PHONE IS NOT NULL) OR (@OLD_CUS_PHONE IS NOT NULL AND @NEW_CUS_PHONE IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_PHONE', @OLD_CUS_PHONE, @NEW_CUS_PHONE, GETDATE())
    IF @OLD_CUS_EMAIL != @NEW_CUS_EMAIL OR (@OLD_CUS_EMAIL IS NULL AND @NEW_CUS_EMAIL IS NOT NULL) OR (@OLD_CUS_EMAIL IS NOT NULL AND @NEW_CUS_EMAIL IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_EMAIL', @OLD_CUS_EMAIL, @NEW_CUS_EMAIL, GETDATE())
    IF @OLD_CUS_BANK_NAME != @NEW_CUS_BANK_NAME OR (@OLD_CUS_BANK_NAME IS NULL AND @NEW_CUS_BANK_NAME IS NOT NULL) OR (@OLD_CUS_BANK_NAME IS NOT NULL AND @NEW_CUS_BANK_NAME IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_BANK_NAME', @OLD_CUS_BANK_NAME, @NEW_CUS_BANK_NAME, GETDATE())
    IF @OLD_CUS_BANK_NUMBER != @NEW_CUS_BANK_NUMBER OR (@OLD_CUS_BANK_NUMBER IS NULL AND @NEW_CUS_BANK_NUMBER IS NOT NULL) OR (@OLD_CUS_BANK_NUMBER IS NOT NULL AND @NEW_CUS_BANK_NUMBER IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'CUSTOMER', 'CUS_BANK_NUMBER', @OLD_CUS_BANK_NUMBER, @NEW_CUS_BANK_NUMBER, GETDATE())
    FETCH NEXT FROM CURSOR_CHECK_CHANGES_CUSTOMER_UPDATE INTO @ROW_ID, @NEW_CUS_ACCOUNT, @NEW_CUS_PASSWORD, @NEW_CUS_NAME, @NEW_CUS_ADDRESS, @NEW_CUS_PHONE, @NEW_CUS_EMAIL, @NEW_CUS_BANK_NAME, @NEW_CUS_BANK_NUMBER, @OLD_CUS_ACCOUNT, @OLD_CUS_PASSWORD, @OLD_CUS_NAME, @OLD_CUS_ADDRESS, @OLD_CUS_PHONE, @OLD_CUS_EMAIL, @OLD_CUS_BANK_NAME, @OLD_CUS_BANK_NUMBER
END
CLOSE CURSOR_CHECK_CHANGES_CUSTOMER_UPDATE

GO
-- CHECK CHANGES ON SHIPPER INFORMATION.
-- SHIPPER INSERT.
CREATE TRIGGER TRIGGER_CHECK_CHANGES_SHIPPER_INSERT
ON SHIPPER
AFTER INSERT
AS
DECLARE @OLD_SHIP_NAME VARCHAR(MAX)
DECLARE @NEW_SHIP_NAME VARCHAR(MAX)
DECLARE @OLD_SHIP_PHONE VARCHAR(MAX)
DECLARE @NEW_SHIP_PHONE VARCHAR(MAX)
DECLARE @OLD_SHIP_EMAIL VARCHAR(MAX)
DECLARE @NEW_SHIP_EMAIL VARCHAR(MAX)
DECLARE @ROW_ID INT

DECLARE CURSOR_CHECK_CHANGES_SHIPPER_INSERT CURSOR FOR
SELECT INSERTED.SHIP_ID, INSERTED.SHIP_NAME, INSERTED.SHIP_PHONE, INSERTED.SHIP_EMAIL FROM INSERTED
OPEN CURSOR_CHECK_CHANGES_SHIPPER_INSERT
FETCH NEXT FROM CURSOR_CHECK_CHANGES_SHIPPER_INSERT INTO @ROW_ID, @NEW_SHIP_NAME, @NEW_SHIP_PHONE, @NEW_SHIP_EMAIL
WHILE @@FETCH_STATUS=0
BEGIN
    IF @OLD_SHIP_NAME != @NEW_SHIP_NAME OR (@OLD_SHIP_NAME IS NULL AND @NEW_SHIP_NAME IS NOT NULL) OR (@OLD_SHIP_NAME IS NOT NULL AND @NEW_SHIP_NAME IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'SHIPPER', 'SHIP_NAME', @OLD_SHIP_NAME, @NEW_SHIP_NAME, GETDATE())
    IF @OLD_SHIP_PHONE != @NEW_SHIP_PHONE OR (@OLD_SHIP_PHONE IS NULL AND @NEW_SHIP_PHONE IS NOT NULL) OR (@OLD_SHIP_PHONE IS NOT NULL AND @NEW_SHIP_PHONE IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'SHIPPER', 'SHIP_PHONE', @OLD_SHIP_PHONE, @NEW_SHIP_PHONE, GETDATE())
    IF @OLD_SHIP_EMAIL != @NEW_SHIP_EMAIL OR (@OLD_SHIP_EMAIL IS NULL AND @NEW_SHIP_EMAIL IS NOT NULL) OR (@OLD_SHIP_EMAIL IS NOT NULL AND @NEW_SHIP_EMAIL IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'SHIPPER', 'SHIP_EMAIL', @OLD_SHIP_EMAIL, @NEW_SHIP_EMAIL, GETDATE())
    FETCH NEXT FROM CURSOR_CHECK_CHANGES_SHIPPER_INSERT INTO @ROW_ID, @NEW_SHIP_NAME, @NEW_SHIP_PHONE, @NEW_SHIP_EMAIL
END
CLOSE CURSOR_CHECK_CHANGES_SHIPPER_INSERT

GO
-- SHIPPER DELETE.
CREATE TRIGGER TRIGGER_CHECK_CHANGES_SHIPPER_DELETE
ON SHIPPER
AFTER DELETE
AS
DECLARE @OLD_SHIP_NAME VARCHAR(MAX)
DECLARE @NEW_SHIP_NAME VARCHAR(MAX)
DECLARE @OLD_SHIP_PHONE INT
DECLARE @NEW_SHIP_PHONE INT
DECLARE @OLD_SHIP_EMAIL INT
DECLARE @NEW_SHIP_EMAIL INT
DECLARE @ROW_ID INT

DECLARE CURSOR_CHECK_CHANGES_SHIPPER_DELETE CURSOR FOR
SELECT DELETED.SHIP_ID, DELETED.SHIP_NAME, DELETED.SHIP_PHONE, DELETED.SHIP_EMAIL FROM DELETED
OPEN CURSOR_CHECK_CHANGES_SHIPPER_DELETE
FETCH NEXT FROM CURSOR_CHECK_CHANGES_SHIPPER_DELETE INTO @ROW_ID, @OLD_SHIP_NAME, @OLD_SHIP_PHONE, @OLD_SHIP_EMAIL
WHILE @@FETCH_STATUS=0
BEGIN
    IF @OLD_SHIP_NAME != @NEW_SHIP_NAME OR (@OLD_SHIP_NAME IS NULL AND @NEW_SHIP_NAME IS NOT NULL) OR (@OLD_SHIP_NAME IS NOT NULL AND @NEW_SHIP_NAME IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'SHIPPER', 'SHIP_NAME', @OLD_SHIP_NAME, @NEW_SHIP_NAME, GETDATE())
    IF @OLD_SHIP_PHONE != @NEW_SHIP_PHONE OR (@OLD_SHIP_PHONE IS NULL AND @NEW_SHIP_PHONE IS NOT NULL) OR (@OLD_SHIP_PHONE IS NOT NULL AND @NEW_SHIP_PHONE IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'SHIPPER', 'SHIP_PHONE', @OLD_SHIP_PHONE, @NEW_SHIP_PHONE, GETDATE())
    IF @OLD_SHIP_EMAIL != @NEW_SHIP_EMAIL OR (@OLD_SHIP_EMAIL IS NULL AND @NEW_SHIP_EMAIL IS NOT NULL) OR (@OLD_SHIP_EMAIL IS NOT NULL AND @NEW_SHIP_EMAIL IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'SHIPPER', 'SHIP_EMAIL', @OLD_SHIP_EMAIL, @NEW_SHIP_EMAIL, GETDATE())
    FETCH NEXT FROM CURSOR_CHECK_CHANGES_SHIPPER_DELETE INTO @ROW_ID, @OLD_SHIP_NAME, @OLD_SHIP_PHONE, @OLD_SHIP_EMAIL
END
CLOSE CURSOR_CHECK_CHANGES_SHIPPER_DELETE

GO
-- SHIPPER UPDATE.
CREATE TRIGGER TRIGGER_CHECK_CHANGES_SHIPPER_UPDATE
ON SHIPPER
AFTER UPDATE
AS
DECLARE @OLD_SHIP_NAME VARCHAR(MAX)
DECLARE @NEW_SHIP_NAME VARCHAR(MAX)
DECLARE @OLD_SHIP_PHONE INT
DECLARE @NEW_SHIP_PHONE INT
DECLARE @OLD_SHIP_EMAIL INT
DECLARE @NEW_SHIP_EMAIL INT
DECLARE @ROW_ID INT

DECLARE CURSOR_CHECK_CHANGES_SHIPPER_UPDATE CURSOR FOR
SELECT INSERTED.SHIP_ID, INSERTED.SHIP_NAME, INSERTED.SHIP_PHONE, INSERTED.SHIP_EMAIL, DELETED.SHIP_NAME, DELETED.SHIP_PHONE, DELETED.SHIP_EMAIL FROM INSERTED JOIN DELETED ON INSERTED.SHIP_ID = DELETED.SHIP_ID
OPEN CURSOR_CHECK_CHANGES_SHIPPER_UPDATE
FETCH NEXT FROM CURSOR_CHECK_CHANGES_SHIPPER_UPDATE INTO @ROW_ID, @NEW_SHIP_NAME, @NEW_SHIP_PHONE, @NEW_SHIP_EMAIL, @OLD_SHIP_NAME, @OLD_SHIP_PHONE, @OLD_SHIP_EMAIL
WHILE @@FETCH_STATUS=0
BEGIN
    IF @OLD_SHIP_NAME != @NEW_SHIP_NAME OR (@OLD_SHIP_NAME IS NULL AND @NEW_SHIP_NAME IS NOT NULL) OR (@OLD_SHIP_NAME IS NOT NULL AND @NEW_SHIP_NAME IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'SHIPPER', 'SHIP_NAME', @OLD_SHIP_NAME, @NEW_SHIP_NAME, GETDATE())
    IF @OLD_SHIP_PHONE != @NEW_SHIP_PHONE OR (@OLD_SHIP_PHONE IS NULL AND @NEW_SHIP_PHONE IS NOT NULL) OR (@OLD_SHIP_PHONE IS NOT NULL AND @NEW_SHIP_PHONE IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'SHIPPER', 'SHIP_PHONE', @OLD_SHIP_PHONE, @NEW_SHIP_PHONE, GETDATE())
    IF @OLD_SHIP_EMAIL != @NEW_SHIP_EMAIL OR (@OLD_SHIP_EMAIL IS NULL AND @NEW_SHIP_EMAIL IS NOT NULL) OR (@OLD_SHIP_EMAIL IS NOT NULL AND @NEW_SHIP_EMAIL IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'SHIPPER', 'SHIP_EMAIL', @OLD_SHIP_EMAIL, @NEW_SHIP_EMAIL, GETDATE())
    FETCH NEXT FROM CURSOR_CHECK_CHANGES_SHIPPER_UPDATE INTO @ROW_ID, @NEW_SHIP_NAME, @NEW_SHIP_PHONE, @NEW_SHIP_EMAIL, @OLD_SHIP_NAME, @OLD_SHIP_PHONE, @OLD_SHIP_EMAIL
END
CLOSE CURSOR_CHECK_CHANGES_SHIPPER_UPDATE

GO
-- CHECK CHANGES ON ITEM INFORMATION.
-- ITEM INSERT.
CREATE TRIGGER TRIGGER_CHECK_CHANGES_ITEM_INSERT
ON ITEM
AFTER INSERT
AS
DECLARE @OLD_ITEM_DESCRIPTION VARCHAR(MAX)
DECLARE @NEW_ITEM_DESCRIPTION VARCHAR(MAX)
DECLARE @OLD_ITEM_PRICE INT
DECLARE @NEW_ITEM_PRICE INT
DECLARE @OLD_ITEM_AMOUNT INT
DECLARE @NEW_ITEM_AMOUNT INT
DECLARE @ROW_ID INT

DECLARE CURSOR_CHECK_CHANGES_ITEM_INSERT CURSOR FOR
SELECT INSERTED.ITEM_ID, INSERTED.ITEM_DESCRIPTION, INSERTED.ITEM_PRICE, INSERTED.ITEM_AMOUNT FROM INSERTED
OPEN CURSOR_CHECK_CHANGES_ITEM_INSERT
FETCH NEXT FROM CURSOR_CHECK_CHANGES_ITEM_INSERT INTO @ROW_ID, @NEW_ITEM_DESCRIPTION, @NEW_ITEM_PRICE, @NEW_ITEM_AMOUNT
WHILE @@FETCH_STATUS=0
BEGIN
    IF @OLD_ITEM_DESCRIPTION != @NEW_ITEM_DESCRIPTION OR (@OLD_ITEM_DESCRIPTION IS NULL AND @NEW_ITEM_DESCRIPTION IS NOT NULL) OR (@OLD_ITEM_DESCRIPTION IS NOT NULL AND @NEW_ITEM_DESCRIPTION IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'ITEM', 'ITEM_DESCRIPTION', @OLD_ITEM_DESCRIPTION, @NEW_ITEM_DESCRIPTION, GETDATE())
    IF @OLD_ITEM_PRICE != @NEW_ITEM_PRICE OR (@OLD_ITEM_PRICE IS NULL AND @NEW_ITEM_PRICE IS NOT NULL) OR (@OLD_ITEM_PRICE IS NOT NULL AND @NEW_ITEM_PRICE IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'ITEM', 'ITEM_PRICE', @OLD_ITEM_PRICE, @NEW_ITEM_PRICE, GETDATE())
    IF @OLD_ITEM_AMOUNT != @NEW_ITEM_AMOUNT OR (@OLD_ITEM_AMOUNT IS NULL AND @NEW_ITEM_AMOUNT IS NOT NULL) OR (@OLD_ITEM_AMOUNT IS NOT NULL AND @NEW_ITEM_AMOUNT IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'ITEM', 'ITEM_AMOUNT', @OLD_ITEM_AMOUNT, @NEW_ITEM_AMOUNT, GETDATE())
    FETCH NEXT FROM CURSOR_CHECK_CHANGES_ITEM_INSERT INTO @ROW_ID, @NEW_ITEM_DESCRIPTION, @NEW_ITEM_PRICE, @NEW_ITEM_AMOUNT
END
CLOSE CURSOR_CHECK_CHANGES_ITEM_INSERT

GO
-- ITEM DELETE.
CREATE TRIGGER TRIGGER_CHECK_CHANGES_ITEM_DELETE
ON ITEM
AFTER DELETE
AS
DECLARE @OLD_ITEM_DESCRIPTION VARCHAR(MAX)
DECLARE @NEW_ITEM_DESCRIPTION VARCHAR(MAX)
DECLARE @OLD_ITEM_PRICE INT
DECLARE @NEW_ITEM_PRICE INT
DECLARE @OLD_ITEM_AMOUNT INT
DECLARE @NEW_ITEM_AMOUNT INT
DECLARE @ROW_ID INT

DECLARE CURSOR_CHECK_CHANGES_ITEM_DELETE CURSOR FOR
SELECT DELETED.ITEM_ID, DELETED.ITEM_DESCRIPTION, DELETED.ITEM_PRICE, DELETED.ITEM_AMOUNT FROM DELETED
OPEN CURSOR_CHECK_CHANGES_ITEM_DELETE
FETCH NEXT FROM CURSOR_CHECK_CHANGES_ITEM_DELETE INTO @ROW_ID, @OLD_ITEM_DESCRIPTION, @OLD_ITEM_PRICE, @OLD_ITEM_AMOUNT
WHILE @@FETCH_STATUS=0
BEGIN
    IF @OLD_ITEM_DESCRIPTION != @NEW_ITEM_DESCRIPTION OR (@OLD_ITEM_DESCRIPTION IS NULL AND @NEW_ITEM_DESCRIPTION IS NOT NULL) OR (@OLD_ITEM_DESCRIPTION IS NOT NULL AND @NEW_ITEM_DESCRIPTION IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'ITEM', 'ITEM_DESCRIPTION', @OLD_ITEM_DESCRIPTION, @NEW_ITEM_DESCRIPTION, GETDATE())
    IF @OLD_ITEM_PRICE != @NEW_ITEM_PRICE OR (@OLD_ITEM_PRICE IS NULL AND @NEW_ITEM_PRICE IS NOT NULL) OR (@OLD_ITEM_PRICE IS NOT NULL AND @NEW_ITEM_PRICE IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'ITEM', 'ITEM_PRICE', @OLD_ITEM_PRICE, @NEW_ITEM_PRICE, GETDATE())
    IF @OLD_ITEM_AMOUNT != @NEW_ITEM_AMOUNT OR (@OLD_ITEM_AMOUNT IS NULL AND @NEW_ITEM_AMOUNT IS NOT NULL) OR (@OLD_ITEM_AMOUNT IS NOT NULL AND @NEW_ITEM_AMOUNT IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'ITEM', 'ITEM_AMOUNT', @OLD_ITEM_AMOUNT, @NEW_ITEM_AMOUNT, GETDATE())
    FETCH NEXT FROM CURSOR_CHECK_CHANGES_ITEM_DELETE INTO @ROW_ID, @OLD_ITEM_DESCRIPTION, @OLD_ITEM_PRICE, @OLD_ITEM_AMOUNT
END
CLOSE CURSOR_CHECK_CHANGES_ITEM_DELETE

GO
-- ITEM UPDATE.
CREATE TRIGGER TRIGGER_CHECK_CHANGES_ITEM_UPDATE
ON ITEM
AFTER UPDATE
AS
DECLARE @OLD_ITEM_DESCRIPTION VARCHAR(MAX)
DECLARE @NEW_ITEM_DESCRIPTION VARCHAR(MAX)
DECLARE @OLD_ITEM_PRICE INT
DECLARE @NEW_ITEM_PRICE INT
DECLARE @OLD_ITEM_AMOUNT INT
DECLARE @NEW_ITEM_AMOUNT INT
DECLARE @ROW_ID INT

DECLARE CURSOR_CHECK_CHANGES_ITEM_UPDATE CURSOR FOR
SELECT INSERTED.ITEM_ID, INSERTED.ITEM_DESCRIPTION, INSERTED.ITEM_PRICE, INSERTED.ITEM_AMOUNT, DELETED.ITEM_DESCRIPTION, DELETED.ITEM_PRICE, DELETED.ITEM_AMOUNT FROM INSERTED JOIN DELETED ON INSERTED.ITEM_ID = DELETED.ITEM_ID
OPEN CURSOR_CHECK_CHANGES_ITEM_UPDATE
FETCH NEXT FROM CURSOR_CHECK_CHANGES_ITEM_UPDATE INTO @ROW_ID, @NEW_ITEM_DESCRIPTION, @NEW_ITEM_PRICE, @NEW_ITEM_AMOUNT, @OLD_ITEM_DESCRIPTION, @OLD_ITEM_PRICE, @OLD_ITEM_AMOUNT
WHILE @@FETCH_STATUS=0
BEGIN
    IF @OLD_ITEM_DESCRIPTION != @NEW_ITEM_DESCRIPTION OR (@OLD_ITEM_DESCRIPTION IS NULL AND @NEW_ITEM_DESCRIPTION IS NOT NULL) OR (@OLD_ITEM_DESCRIPTION IS NOT NULL AND @NEW_ITEM_DESCRIPTION IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'ITEM', 'ITEM_DESCRIPTION', @OLD_ITEM_DESCRIPTION, @NEW_ITEM_DESCRIPTION, GETDATE())
    IF @OLD_ITEM_PRICE != @NEW_ITEM_PRICE OR (@OLD_ITEM_PRICE IS NULL AND @NEW_ITEM_PRICE IS NOT NULL) OR (@OLD_ITEM_PRICE IS NOT NULL AND @NEW_ITEM_PRICE IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'ITEM', 'ITEM_PRICE', @OLD_ITEM_PRICE, @NEW_ITEM_PRICE, GETDATE())
    IF @OLD_ITEM_AMOUNT != @NEW_ITEM_AMOUNT OR (@OLD_ITEM_AMOUNT IS NULL AND @NEW_ITEM_AMOUNT IS NOT NULL) OR (@OLD_ITEM_AMOUNT IS NOT NULL AND @NEW_ITEM_AMOUNT IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'ITEM', 'ITEM_AMOUNT', @OLD_ITEM_AMOUNT, @NEW_ITEM_AMOUNT, GETDATE())
    FETCH NEXT FROM CURSOR_CHECK_CHANGES_ITEM_UPDATE INTO @ROW_ID, @NEW_ITEM_DESCRIPTION, @NEW_ITEM_PRICE, @NEW_ITEM_AMOUNT, @OLD_ITEM_DESCRIPTION, @OLD_ITEM_PRICE, @OLD_ITEM_AMOUNT
END
CLOSE CURSOR_CHECK_CHANGES_ITEM_UPDATE

GO
-- CHECK CHANGES ON VENDOR INFORMATION.
-- VENDOR INSERT.
CREATE TRIGGER TRIGGER_CHECK_CHANGES_VENDOR_INSERT
ON VENDOR
AFTER INSERT
AS
DECLARE @OLD_VEN_NAME VARCHAR(MAX)
DECLARE @NEW_VEN_NAME VARCHAR(MAX)
DECLARE @OLD_VEN_ADDRESS VARCHAR(MAX)
DECLARE @NEW_VEN_ADDRESS VARCHAR(MAX)
DECLARE @OLD_VEN_DESCRIPTION VARCHAR(MAX)
DECLARE @NEW_VEN_DESCRIPTION VARCHAR(MAX)
DECLARE @ROW_ID INT

DECLARE CURSOR_CHECK_CHANGES_VENDOR_INSERT CURSOR FOR
SELECT INSERTED.VEN_ID, INSERTED.VEN_NAME, INSERTED.VEN_ADDRESS, INSERTED.VEN_DESCRIPTION FROM INSERTED
OPEN CURSOR_CHECK_CHANGES_VENDOR_INSERT
FETCH NEXT FROM CURSOR_CHECK_CHANGES_VENDOR_INSERT INTO @ROW_ID, @NEW_VEN_NAME, @NEW_VEN_ADDRESS, @NEW_VEN_DESCRIPTION
WHILE @@FETCH_STATUS=0
BEGIN
    IF @OLD_VEN_NAME != @NEW_VEN_NAME OR (@OLD_VEN_NAME IS NULL AND @NEW_VEN_NAME IS NOT NULL) OR (@OLD_VEN_NAME IS NOT NULL AND @NEW_VEN_NAME IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'VENDOR', 'VEN_NAME', @OLD_VEN_NAME, @NEW_VEN_NAME, GETDATE())
    IF @OLD_VEN_ADDRESS != @NEW_VEN_ADDRESS OR (@OLD_VEN_ADDRESS IS NULL AND @NEW_VEN_ADDRESS IS NOT NULL) OR (@OLD_VEN_ADDRESS IS NOT NULL AND @NEW_VEN_ADDRESS IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'VENDOR', 'VEN_ADDRESS', @OLD_VEN_ADDRESS, @NEW_VEN_ADDRESS, GETDATE())
    IF @OLD_VEN_DESCRIPTION != @NEW_VEN_DESCRIPTION OR (@OLD_VEN_DESCRIPTION IS NULL AND @NEW_VEN_DESCRIPTION IS NOT NULL) OR (@OLD_VEN_DESCRIPTION IS NOT NULL AND @NEW_VEN_DESCRIPTION IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'VENDOR', 'VEN_DESCRIPTION', @OLD_VEN_DESCRIPTION, @NEW_VEN_DESCRIPTION, GETDATE())
    FETCH NEXT FROM CURSOR_CHECK_CHANGES_VENDOR_INSERT INTO @ROW_ID, @NEW_VEN_NAME, @NEW_VEN_ADDRESS, @NEW_VEN_DESCRIPTION
END
CLOSE CURSOR_CHECK_CHANGES_VENDOR_INSERT

GO
-- VENDOR DELETE.
CREATE TRIGGER TRIGGER_CHECK_CHANGES_VENDOR_DELETE
ON VENDOR
AFTER DELETE
AS
DECLARE @OLD_VEN_NAME VARCHAR(MAX)
DECLARE @NEW_VEN_NAME VARCHAR(MAX)
DECLARE @OLD_VEN_ADDRESS VARCHAR(MAX)
DECLARE @NEW_VEN_ADDRESS VARCHAR(MAX)
DECLARE @OLD_VEN_DESCRIPTION VARCHAR(MAX)
DECLARE @NEW_VEN_DESCRIPTION VARCHAR(MAX)
DECLARE @ROW_ID INT

DECLARE CURSOR_CHECK_CHANGES_VENDOR_DELETE CURSOR FOR
SELECT DELETED.VEN_ID, DELETED.VEN_NAME, DELETED.VEN_ADDRESS, DELETED.VEN_DESCRIPTION FROM DELETED
OPEN CURSOR_CHECK_CHANGES_VENDOR_DELETE
FETCH NEXT FROM CURSOR_CHECK_CHANGES_VENDOR_DELETE INTO @ROW_ID, @OLD_VEN_NAME, @OLD_VEN_ADDRESS, @OLD_VEN_DESCRIPTION
WHILE @@FETCH_STATUS=0
BEGIN
    IF @OLD_VEN_NAME != @NEW_VEN_NAME OR (@OLD_VEN_NAME IS NULL AND @NEW_VEN_NAME IS NOT NULL) OR (@OLD_VEN_NAME IS NOT NULL AND @NEW_VEN_NAME IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'VENDOR', 'VEN_NAME', @OLD_VEN_NAME, @NEW_VEN_NAME, GETDATE())
    IF @OLD_VEN_ADDRESS != @NEW_VEN_ADDRESS OR (@OLD_VEN_ADDRESS IS NULL AND @NEW_VEN_ADDRESS IS NOT NULL) OR (@OLD_VEN_ADDRESS IS NOT NULL AND @NEW_VEN_ADDRESS IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'VENDOR', 'VEN_ADDRESS', @OLD_VEN_ADDRESS, @NEW_VEN_ADDRESS, GETDATE())
    IF @OLD_VEN_DESCRIPTION != @NEW_VEN_DESCRIPTION OR (@OLD_VEN_DESCRIPTION IS NULL AND @NEW_VEN_DESCRIPTION IS NOT NULL) OR (@OLD_VEN_DESCRIPTION IS NOT NULL AND @NEW_VEN_DESCRIPTION IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'VENDOR', 'VEN_DESCRIPTION', @OLD_VEN_DESCRIPTION, @NEW_VEN_DESCRIPTION, GETDATE())
    FETCH NEXT FROM CURSOR_CHECK_CHANGES_VENDOR_DELETE INTO @ROW_ID, @OLD_VEN_NAME, @OLD_VEN_ADDRESS, @OLD_VEN_DESCRIPTION
END
CLOSE CURSOR_CHECK_CHANGES_VENDOR_DELETE

GO
-- VENDOR UPDATE.
CREATE TRIGGER TRIGGER_CHECK_CHANGES_VENDOR_UPDATE
ON VENDOR
AFTER UPDATE
AS
DECLARE @OLD_VEN_NAME VARCHAR(MAX)
DECLARE @NEW_VEN_NAME VARCHAR(MAX)
DECLARE @OLD_VEN_ADDRESS VARCHAR(MAX)
DECLARE @NEW_VEN_ADDRESS VARCHAR(MAX)
DECLARE @OLD_VEN_DESCRIPTION VARCHAR(MAX)
DECLARE @NEW_VEN_DESCRIPTION VARCHAR(MAX)
DECLARE @ROW_ID INT

DECLARE CURSOR_CHECK_CHANGES_VENDOR_UPDATE CURSOR FOR
SELECT INSERTED.VEN_ID, INSERTED.VEN_NAME, INSERTED.VEN_ADDRESS, INSERTED.VEN_DESCRIPTION, DELETED.VEN_NAME, DELETED.VEN_ADDRESS, DELETED.VEN_DESCRIPTION FROM INSERTED JOIN DELETED ON INSERTED.VEN_ID = DELETED.VEN_ID
OPEN CURSOR_CHECK_CHANGES_VENDOR_UPDATE
FETCH NEXT FROM CURSOR_CHECK_CHANGES_VENDOR_UPDATE INTO @ROW_ID, @NEW_VEN_NAME, @NEW_VEN_ADDRESS, @NEW_VEN_DESCRIPTION, @OLD_VEN_NAME, @OLD_VEN_ADDRESS, @OLD_VEN_DESCRIPTION
WHILE @@FETCH_STATUS=0
BEGIN
    IF @OLD_VEN_NAME != @NEW_VEN_NAME OR (@OLD_VEN_NAME IS NULL AND @NEW_VEN_NAME IS NOT NULL) OR (@OLD_VEN_NAME IS NOT NULL AND @NEW_VEN_NAME IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'VENDOR', 'VEN_NAME', @OLD_VEN_NAME, @NEW_VEN_NAME, GETDATE())
    IF @OLD_VEN_ADDRESS != @NEW_VEN_ADDRESS OR (@OLD_VEN_ADDRESS IS NULL AND @NEW_VEN_ADDRESS IS NOT NULL) OR (@OLD_VEN_ADDRESS IS NOT NULL AND @NEW_VEN_ADDRESS IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'VENDOR', 'VEN_ADDRESS', @OLD_VEN_ADDRESS, @NEW_VEN_ADDRESS, GETDATE())
    IF @OLD_VEN_DESCRIPTION != @NEW_VEN_DESCRIPTION OR (@OLD_VEN_DESCRIPTION IS NULL AND @NEW_VEN_DESCRIPTION IS NOT NULL) OR (@OLD_VEN_DESCRIPTION IS NOT NULL AND @NEW_VEN_DESCRIPTION IS NULL)
    INSERT INTO CHECK_CHANGES (ROW_ID, TABLE_NAME, COLUMN_NAME, OLD_DATA, NEW_DATA, CHANGE_TIME) VALUES (@ROW_ID, 'VENDOR', 'VEN_DESCRIPTION', @OLD_VEN_DESCRIPTION, @NEW_VEN_DESCRIPTION, GETDATE())
    FETCH NEXT FROM CURSOR_CHECK_CHANGES_VENDOR_UPDATE INTO @ROW_ID, @NEW_VEN_NAME, @NEW_VEN_ADDRESS, @NEW_VEN_DESCRIPTION, @OLD_VEN_NAME, @OLD_VEN_ADDRESS, @OLD_VEN_DESCRIPTION
END
CLOSE CURSOR_CHECK_CHANGES_VENDOR_UPDATE

--------------------------------------------------------------------------------
/* END OF DATABASE DESIGN
PROCEED TO SAMPLE DEMO. */
--------------------------------------------------------------------------------

-- SAMPLE TABLES ___________________________________________________

GO
-- CUSTOMER
DECLARE @COUNT INT
SET @COUNT = 1
WHILE @COUNT <= 30
BEGIN
    INSERT INTO CUSTOMER (CUS_ACCOUNT, CUS_PASSWORD, CUS_NAME, CUS_ADDRESS, CUS_PHONE, CUS_EMAIL, CUS_BANK_NAME, CUS_BANK_NUMBER)
    VALUES (CONCAT('ACCOUNT ', @COUNT), 'PASSWORD', CONCAT('NAME ', @COUNT), CONCAT('ADDRESS ', @COUNT), CONCAT('PHONE ', @COUNT), CONCAT('EMAIL ', @COUNT), CONCAT('BANK_NAME ', @COUNT), CONCAT('BANK_NUMBER ', @COUNT))
    SET @COUNT = @COUNT +1
END

GO
-- SHIPPER
DECLARE @COUNT INT
SET @COUNT = 1
WHILE @COUNT <= 30
BEGIN
    INSERT INTO SHIPPER (SHIP_NAME, SHIP_PHONE, SHIP_EMAIL)
    VALUES (CONCAT('SHIP_NAME ', @COUNT), CONCAT('SHIP_PHONE ', @COUNT), CONCAT('SHIP_EMAIL ', @COUNT))
    SET @COUNT = @COUNT +1
END

GO
-- VENDOR
DECLARE @COUNT INT
SET @COUNT = 1
WHILE @COUNT <= 30
BEGIN
    INSERT INTO VENDOR (VEN_NAME, VEN_ADDRESS)
    VALUES (CONCAT('VEN_NAME ', @COUNT), CONCAT('VEN_ADDRESS ', @COUNT))
    SET @COUNT = @COUNT +1
END

GO
-- ITEM. BULK INSERTED TO CHECK THE BEHAVIOR OF TRIGGER "CHECK_CHANGES" TO HANDLE BULK UPDATE.
INSERT INTO ITEM (ITEM_DESCRIPTION, ITEM_TYPE, ITEM_PRICE, ITEM_AMOUNT, VEN_ID) -- All products are hypothetical.
VALUES -- Control values sample for testing purpose.
('Re:Zero − Starting Life in Another World', 'BOOKS', 1, 1, 1),
('Bakemonogatari', 'BOOKS', 2, 2, 2),
('KonoSuba', 'BOOKS', 3, 3, 3),
('The Phantom of the Opera', 'BOOKS', 4, 4, 4),
('Sherlock Holmes', 'BOOKS', 5, 5, 5),
('Fullmetal Alchemist', 'BOOKS', 6, 6, 6),
('Don Quixote', 'BOOKS', 7, 7, 7),
('The Great Gatsby', 'BOOKS', 8, 8, 8),
('The Lord of the Rings', 'BOOKS', 9, 9, 9),
('OreGairu', 'BOOKS', 10, 10, 10),
('LEGO', 'TOYS', 11, 1000, 11),
('Monopoly', 'TOYS', 12, 1000, 12),
('Barbie', 'TOYS', 13, 1000, 13),
('Frisbee', 'TOYS', 14, 1000, 14),
('Cigarette', 'TOYS', 15, 1000, 15),
('Scissor', 'TOYS', 16, 1000, 16),
('A random toy', 'TOYS', 17, 1000, 17),
('I cannot think of another name', 'TOYS', 18, 1000, 18),
('Hypothetical toy', 'TOYS', 19, 1000, 19),
('I did not say that', 'TOYS', 20, 1000, 20),
('RUGER LCP', 'GUNS', 1, 1000, 21),
('UZI', 'GUNS', 1, 1000, 21),
('DESERT EAGLE', 'GUNS', 1, 1000, 21),
('MP5', 'GUNS', 1, 1000, 21),
('M4A1', 'GUNS', 1, 1000, 21),
('AK47', 'GUNS', 1, 1000, 21),
('GLOCK', 'GUNS', 1, 1000, 21),
('THOMPSON', 'GUNS', 1, 1000, 21),
('GYROJET', 'GUNS', 1, 1000, 21),
('GATLING', 'GUNS', 1, 1000, 21);

GO

--------------------------------------------------------------------------------

-- TEST 1
ADD_TO_CART @CUS=1, @ITEM=1, @AMOUNT=2
ADD_TO_CART @CUS=1, @ITEM=2, @AMOUNT=2
ADD_TO_CART @CUS=1, @ITEM=3, @AMOUNT=3
SELECT * FROM CART_PENDING
VIEW_CART @CUS=1
PURCHASE_CART @CUS=1
-- CANNOT PURCHASE BECAUSE AMOUNT IN CART EXCEEDED AMOUNT IN STORAGE. WE ONLY HAVE 1 UNIT LEFT FOR ITEM 1.
ADD_TO_CART @CUS=1, @ITEM=1, @AMOUNT=1
VIEW_CART @CUS=1
PURCHASE_CART @CUS=1
-- PURCHASE SUCCESSFUL.
SELECT * FROM DEAL WHERE CUS_ID=1
SHIPPING_SLIP @DEAL_ID=1
SELECT * FROM DEAL_ORDER WHERE DEAL_ID=1
SELECT * FROM ITEM
-- SHIPPING SLIP
FINISHED_DELIVERY @DEAL_ID=1
SELECT * FROM DEAL WHERE CUS_ID=1
-- SHIPPER SHIPPED SUCESSFULLY AND IT IS RECORDED IN THE TABLE.

-- TEST 2
ADD_TO_CART @CUS=1, @ITEM=4, @AMOUNT=1
ADD_TO_CART @CUS=1, @ITEM=5, @AMOUNT=1
ADD_TO_CART @CUS=1, @ITEM=6, @AMOUNT=1
VIEW_CART @CUS=1
PURCHASE_CART @CUS=1
SELECT * FROM DEAL WHERE CUS_ID=1
SHIPPING_SLIP @DEAL_ID=2
SELECT * FROM DEAL_ORDER WHERE DEAL_ID=2
SELECT * FROM ITEM

-- OTHER VIEWS
SELECT * FROM NOT_SHIPPED_DEALS
SELECT * FROM SUCCESSFUL_DEALS_COUNT

-- AUDIT LOG VIEW
SELECT * FROM CHECK_CHANGES

-- TEST 3
ADD_TO_CART @CUS=2, @ITEM=11, @AMOUNT=1
ADD_TO_CART @CUS=3, @ITEM=12, @AMOUNT=1
PURCHASE_CART @CUS=2
SELECT * FROM DEAL WHERE CUS_ID=2
SHIPPING_SLIP @DEAL_ID=3
SELECT * FROM DEAL_ORDER WHERE DEAL_ID=3
SELECT * FROM ITEM

SELECT * FROM ADVERTISEMENT